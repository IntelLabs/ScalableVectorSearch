/**
 *    Copyright (C) 2023-present, Intel Corporation
 *
 *    You can redistribute and/or modify this software under the terms of the
 *    GNU Affero General Public License version 3.
 *
 *    You should have received a copy of the GNU Affero General Public License
 *    version 3 along with this software. If not, see
 *    <https://www.gnu.org/licenses/agpl-3.0.en.html>.
 */

#pragma once

#include "svs/concepts/data.h"
#include "svs/core/data/io.h"
#include "svs/core/data/simple.h"
#include "svs/core/data/view.h"
#include "svs/lib/datatype.h"
#include "svs/lib/dispatcher.h"
#include "svs/lib/saveload.h"

#include "fmt/std.h"
#include <filesystem>

namespace svs {

template <typename T, size_t Extent = Dynamic>
data::SimpleData<T, Extent> load_data(const std::filesystem::path& path) {
    return data::SimpleData<T, Extent>::load(path);
}

// Forward Declaration
template <typename T, size_t Dims, typename Alloc> class VectorDataLoader;

template <typename Allocator = HugepageAllocator<std::byte>>
struct UnspecializedVectorDataLoader {
    template <typename T> using rebind_alloc = lib::rebind_allocator_t<T, Allocator>;

    UnspecializedVectorDataLoader() = default;
    UnspecializedVectorDataLoader(
        const std::filesystem::path& path, DataType type, size_t dims = Dynamic
    )

        : path_{path}
        , type_{type}
        , dims_{dims} {}

    UnspecializedVectorDataLoader(
        const std::filesystem::path& path,
        DataType type,
        Allocator allocator,
        size_t dims = Dynamic
    )
        : path_{path}
        , type_{type}
        , dims_{dims}
        , allocator_{std::move(allocator)} {}

    // Refine into a fully specialized ``VectorDataLoader``.
    template <typename T, size_t Dims = Dynamic>
    VectorDataLoader<T, Dims, rebind_alloc<T>>
    refine(lib::Type<T> SVS_UNUSED(type), lib::Val<Dims> SVS_UNUSED(dims) = {}) const {
        using Other = rebind_alloc<T>;
        return VectorDataLoader<T, Dims, Other>{*this};
    }

    ///// Members
  public:
    std::filesystem::path path_;
    DataType type_;
    size_t dims_;
    Allocator allocator_ = {};
};

///
/// @brief Loader for uncompressed vector datasets.
///
/// @tparam T The element type of the encoded vectors.
///     Typically, this will be a floating point type like ``float`` or ``svs::Float16``
///     but may be an integer type as well for certain datsets.
/// @tparam Extent The compile-time dimensionality of the vectors to be read.
///     May provide a performance boost if given. Default: ``svs::Dynamic``.
/// @tparam Allocator The allocator to use for the memory backing the data when loaded.
///
template <typename T, size_t Extent = Dynamic, typename Allocator = HugepageAllocator<T>>
class VectorDataLoader {
  public:
    // Hook into the loading framework.
    using toml_type = toml::table;
    static constexpr bool is_version_free = false;

    /// @brief The full type of the loaded dataset.
    using return_type = data::SimpleData<T, Extent, Allocator>;

    ////// Constructors

    ///
    /// @brief Construct a new VectorDataLoader.
    ///
    /// @param path The path to the dataset on disk. See detailed notes.
    /// @param allocator The allocator to be used.
    ///
    /// Typically, ``path`` should point to a directory generated by one of the index
    /// save methods. This will provide the most error checking. However, the path can
    /// also point directly to the following files:
    ///
    /// * Any "*.svs" file, which is the native file path used by the SVS library.
    /// * Any "[f/b/i]vecs" file typically used by similarity search libraries.
    ///
    VectorDataLoader(const std::filesystem::path& path, const Allocator& allocator)
        : path_{path}
        , allocator_{allocator} {}

    VectorDataLoader(const std::filesystem::path& path)
        : path_{path} {}

    template <typename Other>
    VectorDataLoader(const UnspecializedVectorDataLoader<Other>& other)
        : VectorDataLoader{other.path_, other.allocator_} {
        // Validate the refinement.
        if (datatype_v<T> != other.type_) {
            throw ANNEXCEPTION("Type mismatch!");
        }

        if constexpr (Extent != Dynamic) {
            auto other_dims = other.dims_;
            if (other_dims != Dynamic && other_dims != Extent) {
                throw ANNEXCEPTION("Dims mismatch!");
            }
        }
    }

    /// @brief Load the dataset from disk.
    return_type load() const { return return_type::load(path_, allocator_); }

    /// @brief Return the file path given when this class was constructed.
    const std::filesystem::path& get_path() const { return path_; }

  public:
    std::filesystem::path path_ = {};
    Allocator allocator_ = {};
};

// TODO: Further constrain allocator to be rebind-convertible
template <typename T, size_t Extent, typename Alloc1, typename Alloc2>
struct lib::DispatchConverter<
    UnspecializedVectorDataLoader<Alloc1>,
    VectorDataLoader<T, Extent, Alloc2>> {
    static int64_t match(const UnspecializedVectorDataLoader<Alloc1>& loader) {
        if (loader.type_ != datatype_v<T>) {
            return lib::invalid_match;
        }

        auto dims = loader.dims_;
        if (dims == Extent) {
            return lib::perfect_match;
        }

        if constexpr (Extent == Dynamic) {
            return lib::imperfect_match;
        }
        return lib::invalid_match;
    }

    static VectorDataLoader<T, Extent, Alloc2>
    convert(const UnspecializedVectorDataLoader<Alloc1>& loader) {
        return loader.template refine<T, Extent>(lib::Type<T>());
    }

    static std::string description() {
        if constexpr (Extent == Dynamic) {
            auto t = datatype_v<T>;
            return fmt::format(
                "VectorDataLoader with element type {} and any dimension", t
            );
        } else {
            return fmt::format(
                "VectorDataLoader with element type {} and {} dimensions",
                datatype_v<T>,
                Extent
            );
        }
    }
};

} // namespace svs
