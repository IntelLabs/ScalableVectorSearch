/**
 *    Copyright (C) 2023-present, Intel Corporation
 *
 *    You can redistribute and/or modify this software under the terms of the
 *    GNU Affero General Public License version 3.
 *
 *    You should have received a copy of the GNU Affero General Public License
 *    version 3 along with this software. If not, see
 *    <https://www.gnu.org/licenses/agpl-3.0.en.html>.
 */

#pragma once

#include "svs/core/data/block.h"
#include "svs/core/data/io.h"
#include "svs/core/data/simple.h"
#include "svs/lib/datatype.h"
#include "svs/lib/saveload.h"
#include "svs/lib/traits.h"

#include <filesystem>

namespace svs {

///
/// @brief Tag type to indicate that objects yielding this tag need no operations to load.
///
/// Typically, this is because the corresponding object is already loaded into memory (or
/// otherwise accessible) and can simply be forwarded to its destination.
///
struct NoopLoaderTag : public lib::AbstractLoaderTag {};

namespace lib {
/// @brief Specialize all instances of `ImmutableMemoryDataset` to be "already loaded".
template <data::ImmutableMemoryDataset Data> struct LoaderTraits<Data> {
    using type = NoopLoaderTag;
};
} // namespace lib

struct VectorDataLoaderTag : public lib::AbstractLoaderTag {};

///
/// @brief The default dataset to use for storing vectors in R^n.
///
/// @tparam T The element type used to encode each value of the vectors.
/// @tparam Extent The static dimensionality of each vector. If this is left as a run-time
///     decision, the value ``svs::Dynamic`` is used.
///
template <typename T, size_t Extent = Dynamic>
using DefaultDataset = data::SimplePolymorphicData<T, Extent>;

// Forward Declaration
template <typename T, size_t Dims, typename Allocator> class VectorDataLoader;

template <typename Allocator = HugepageAllocator> struct UnspecializedVectorDataLoader {
    UnspecializedVectorDataLoader() = default;
    UnspecializedVectorDataLoader(
        const std::filesystem::path& path, DataType type, size_t dims = Dynamic
    )

        : path_{path}
        , type_{type}
        , dims_{dims} {}

    UnspecializedVectorDataLoader(
        const std::filesystem::path& path,
        DataType type,
        Allocator allocator,
        size_t dims = Dynamic
    )
        : path_{path}
        , type_{type}
        , dims_{dims}
        , allocator_{std::move(allocator)} {}

    template <typename T, size_t Dims = Dynamic>
    VectorDataLoader<T, Dims, Allocator> refine(
        meta::Type<T> SVS_UNUSED(type), meta::Val<Dims> SVS_UNUSED(dims) = meta::Val<Dims>()
    ) const {
        return VectorDataLoader<T, Dims, Allocator>{*this};
    }

    ///// Members
  public:
    std::filesystem::path path_;
    DataType type_;
    size_t dims_;
    Allocator allocator_ = {};
};

///
/// @brief Loader for uncompressed vector datasets.
///
/// @tparam T The element type of the encoded vectors.
///     Typically, this will be a floating point type like ``float`` or ``svs::Float16``
///     but may be an integer type as well for certain datsets.
/// @tparam Extent The compile-time dimensionality of the vectors to be read.
///     May provide a performance boost if given. Default: ``svs::Dynamic``.
/// @tparam Allocator The allocator to use for the memory backing the data when loaded.
///
template <typename T, size_t Extent = Dynamic, typename Allocator = HugepageAllocator>
class VectorDataLoader {
  public:
    // Dispatch tag for consumers.
    using loader_tag = VectorDataLoaderTag;

    ////// Constructors

    /// @brief Default constructor.
    VectorDataLoader()
        : allocator_{} {}
    VectorDataLoader(lib::InferPath SVS_UNUSED(tag), Allocator allocator = {})
        : allocator_{std::move(allocator)}
        , path_{std::nullopt} {}

    ///
    /// @brief Construct a new VectorDataLoader.
    ///
    /// @param path The path to the dataset on disk. See detailed notes.
    /// @param allocator The allocator to use.
    ///
    /// Typically, ``path`` should point to a directory generated by one of the index
    /// save methods. This will provide the most error checking. However, the path can
    /// also point directly to the following files:
    ///
    /// * Any "*.svs" file, which is the native file path used by the SVS library.
    /// * Any "[f/b/i]vecs" file typically used by similarity search libraries.
    ///
    VectorDataLoader(const std::filesystem::path& path, Allocator allocator = {})
        : allocator_{std::move(allocator)}
        , path_{path} {}

    VectorDataLoader(const UnspecializedVectorDataLoader<Allocator>& other)
        : VectorDataLoader{other.path_, other.allocator_} {
        // Validate the refinement.
        if (datatype_v<T> != other.type_) {
            throw ANNEXCEPTION("Type mismatch!");
        }

        if constexpr (Extent != Dynamic) {
            auto other_dims = other.dims_;
            if (other_dims != Dynamic && other_dims != Extent) {
                throw ANNEXCEPTION("Dims mismatch!");
            }
        }
    }

    DefaultDataset<T, Extent> unsafe_load_direct() const {
        return io::auto_load<T, Extent>(*path_, allocator_);
    }

    /// @brief Load the dataset from disk.
    DefaultDataset<T, Extent> load() const {
        // First, check that a file in the optional actually exists.
        if (!path_.has_value()) {
            throw ANNEXCEPTION(
                "Trying to load a vector dataset without providing a file path!"
            );
        }

        // If the filename is a directory or ends in "toml" - assume we're trying to do
        // a full reload procedure.
        const auto& path = *path_;
        if (maybe_config_file(path) || std::filesystem::is_directory(path)) {
            auto loader = lib::LoadOverride{[&](const toml::table& table,
                                                const lib::LoadContext& ctx,
                                                const lib::Version& version) {
                return load_from_table(table, ctx, version);
            }};
            return lib::load(loader, path);
        }

        return unsafe_load_direct();
    }

    // Reload a save dataset.
    // N.B.: This must be kept in-sync with the saving methods for various data
    // implementations.
    DefaultDataset<T, Extent> load(
        const toml::table& table, const lib::LoadContext& ctx, const lib::Version& version
    ) const {
        // If this object was constructed with an existing file, then use that as an
        // override for loading.
        //
        // Error handling on this path is more minimal.
        if (path_.has_value()) {
            return unsafe_load_direct();
        }

        return load_from_table(table, ctx, version);
    }

    DefaultDataset<T, Extent> load_from_table(
        const toml::table& table, const lib::LoadContext& ctx, const lib::Version version
    ) const {
        if (version != lib::Version(0, 0, 0)) {
            throw ANNEXCEPTION("Unhandled version!");
        }

        // Perform a sanity check on the element type.
        // Make sure we're loading the correct kind.
        auto data_eltype_name = get(table, "eltype").value();
        constexpr auto this_eltype_name = name<datatype_v<T>>();
        if (data_eltype_name != this_eltype_name) {
            throw ANNEXCEPTION(
                "Trying to load an uncompressed dataset with element types ",
                data_eltype_name,
                " to a dataset with element types ",
                this_eltype_name
            );
        }

        // Now that this is out of the way, resolve the file and load the data.
        auto uuid = lib::UUID(get(table, "uuid").value());
        auto binaryfile = io::find_uuid(ctx.get_directory(), uuid);
        if (!binaryfile.has_value()) {
            throw ANNEXCEPTION("Could not open file with uuid ", uuid.str(), '!');
        }
        return io::load_dataset<T, Extent>(binaryfile.value(), allocator_);
    }

    /// @brief Return the file path given when this class was constructed.
    const std::filesystem::path& get_path() const {
        if (path_) {
            return *path_;
        }
        throw ANNEXCEPTION("Accessed an empty optional path variable in a context that "
                           "expected it to be non-empty!");
    }

  private:
    Allocator allocator_;
    std::optional<std::filesystem::path> path_ = {};
};
} // namespace svs
