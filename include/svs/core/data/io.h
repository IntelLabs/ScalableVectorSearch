/**
 *    Copyright (C) 2023-present, Intel Corporation
 *
 *    You can redistribute and/or modify this software under the terms of the
 *    GNU Affero General Public License version 3.
 *
 *    You should have received a copy of the GNU Affero General Public License
 *    version 3 along with this software. If not, see
 *    <https://www.gnu.org/licenses/agpl-3.0.en.html>.
 */

#pragma once

#include "svs/core/data/abstract_io.h"
#include "svs/core/data/block.h"
#include "svs/core/data/simple.h"
#include "svs/core/io.h"

#include "svs/lib/array.h"
#include "svs/lib/exception.h"
#include "svs/lib/memory.h"
#include "svs/lib/meta.h"
#include "svs/lib/misc.h"

namespace svs::io {

namespace detail {
inline void static_size_check(size_t expected, size_t actual) {
    if (expected != actual) {
        throw ANNEXCEPTION(
            "Trying to populate a dataset with static extent ",
            expected,
            " while the loaded dataset has dimension ",
            actual,
            "!"
        );
    }
}
} // namespace detail

/////
///// Dataset Loading
/////

constexpr lib::PriorityTag<2> default_load_tag = lib::PriorityTag<2>();

// Generic dataset loading.
template <typename T, size_t Extent, typename File, typename Allocator>
data::SimplePolymorphicData<T, Extent> load_simple(
    const File& file, const Allocator& allocator, lib::PriorityTag<0> SVS_UNUSED(tag)
) {
    // Perform a size check.
    auto [vectors_to_read, ndims] = file.get_dims();
    if constexpr (Extent != Dynamic) {
        detail::static_size_check(Extent, ndims);
    }

    auto data = data::SimplePolymorphicData<T, Extent>(allocator, vectors_to_read, ndims);
    populate(data, file);
    return data;
}

// Load blocked dataset.
template <typename T, size_t Extent, typename File>
data::BlockedData<T, Extent> load_blocked(const File& file) {
    // Perform a size check.
    auto [vectors_to_read, ndims] = file.get_dims();
    if constexpr (Extent != Dynamic) {
        detail::static_size_check(Extent, ndims);
    }

    auto data = data::BlockedData<T, Extent>{vectors_to_read, ndims};
    populate(data, file);
    return data;
}

namespace detail {
// Promote untyped string-like arguments to a `NativeFile`.
template <typename T> const T& to_native(const T& x) { return x; }
inline NativeFile to_native(const std::string& x) { return NativeFile(x); }
inline NativeFile to_native(const std::string_view& x) { return to_native(std::string(x)); }
inline NativeFile to_native(const std::filesystem::path& x) { return NativeFile(x); }
} // namespace detail

template <
    typename T,
    size_t Extent,
    typename File,
    lib::memory::MemoryAllocator Allocator = lib::DefaultAllocator>
auto load_dataset(const File& file, const Allocator& allocator = {}) {
    return load_simple<T, Extent>(detail::to_native(file), allocator, default_load_tag);
}

///
/// Load a dataset into memory using a polymorphic allocator.
///
/// @tparam T The data type of the dataset.
/// @tparam Extent The compile time dimensionality of the data. Set to
///     `svs::Dynamic` for dynamic sizing.
/// @tparam File The type of the dataset file to be read.
///
/// @param file The dataset file to be read.
/// @param allocator The allocator to use to load memory.
///
template <typename T, size_t Extent, typename File, typename... Ts>
auto load_dataset(const File& file, const std::variant<Ts...>& allocator) {
    auto visitor = [&](const auto& alloc) { return load_dataset<T, Extent>(file, alloc); };
    return std::visit(visitor, allocator);
}

///
/// @brief Load a dataset from file. Automcatically detect the file type based on extension.
///
/// @tparam T The element type of the vector components in the file.
/// @tparam Extent The compile-time dimensionality of the dataset to load. This will be
///     check by the actual loading mechanism if it's able to.
/// @tparam Allocator The allocator type to use for the resulting dataset.
///
/// @param filename The path to the file on disk.
/// @param allocator The allocator instance to use for allocation.
///
/// Recognized file extentions:
/// * .svs: The native file format for this library.
/// * .vecs: The usual [f/b/i]vecs form.
/// * .bin: Files generated by DiskANN.
///
template <typename T, size_t Extent = Dynamic, typename Allocator = lib::DefaultAllocator>
auto auto_load(
    const std::string& filename, const Allocator& allocator = lib::DefaultAllocator()
) {
    if (filename.ends_with("svs")) {
        return load_dataset<T, Extent>(io::NativeFile(filename), allocator);
    } else if (filename.ends_with("vecs")) {
        return load_dataset<T, Extent>(io::vecs::VecsFile<T>(filename), allocator);
    } else if (filename.ends_with("bin")) {
        return load_dataset<T, Extent>(io::binary::BinaryFile(filename), allocator);
    } else {
        throw ANNEXCEPTION("Unknown file extension for input file: ", filename, ".");
    }
}

} // namespace svs::io
